# Web
- 거미줄처럼 이루어짐
- 클라이언트와 서버, 서버와 서버 등 연결을 함
    - 클라이언트에서 서버에 정보를 요구하고, 서버는 정보를 제공한다

### Frontend? Backend?
- Frontend (HTML, CSS, JS)
    - 컴퓨터에서 실행되는 코드
    - 사용자들이 보는 화면
    - Backend와 상호 작용 
    - 컴퓨터나 네트워크의 발전으로 많은 양의 코드를 실행할 수 있음으로 발전을 많이 함
- Backend
    - 여기서 처리하고, FrontEnd로 보냄
    - DB를 꺼내고, 저장함
    - Backend에 FrontEnd 내용이 포함됨


# django 명령어
```powershell
# 환경 설정등을 할 수 있는 기본적이 프로젝트가 생성
django-admin startproject firstdjango .

# 이 상태에서 앱을 실행할 수 있음
python manage.py runserver

# first 웹앱을 생성
python manage.py startapp first
```

- manage.py: 쟝고 앱을 관리하기 위한 각종 명령어를 내장하고 있는 스크립트 파일
- firstdjango (프로젝트 폴더)
    - settings.py: 프로젝트 전바에 걸친 설정을 위한 파일
    - urls: 어떤 웹앱의 페이지를 어떤 주소에 연결 시킬지 정의하는 파일
    - wsgi.py: 웹 사이트 실행 프로세스와 관련하여 사용되는 파일
- first (웹 앱 폴더)
    - admin.py: 쟝고 관리자 웹을 구성하기 위한 파일
    - app.py: 쟝고 웹앱에 대한 설정을 위한 파일
    - models.py: DB에 정의하기 위한 모델을 정의해두는 코드를 위한 파일
    - views.py: 웹 페이지나 웹 요청등을 처리하는 코드를 작성하는 파일

## URL 매핑 규칙
1. 일치하는 문자열: 'select/', 'select/10/'
1. 변수화: path converter 사용
    - slug: -(하이픈), _(언더 스코어)를 포함한 영숫자 문자열
    ```py
    urlpatterns = [
        path('articles/2003/', views.special_case_2003),
        path('articles/<int:year>/', views.year_archive),
        path('articles/<int:year>/<int:month>/', views.month_archive),
        path('articles/<int:year>/<int:month>/<slug:slug>/', views.article_detail),
    ]
    ```
1. 정규식 사용
    - 정규 표현식 사용
    ```py
    urlpatterns = [
        re_path(r'^articles/(?P<year>[0-9]{4})/$', views.year_archive),
        re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$', views.month_archive),
        re_path(r'^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$', views.article_detail),
    ]
    ```

### template 활용하기
``` py
# first/templates/index.html
<html>
<head>
    <meta charset="utf-8">
    <title></title>
</head>
<body>
    Hello world!
</body>
</html>
```

```py 
first/views.py
from django.template import loader  ## 추가


def index(request):
    template = loader.get_template('index.html') ## 수정
    context = {}  ## 수정
    return HttpResponse(template.render(context, request))  ## 수정
```

```py
# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'first', ## 추가
]
```

## Django Model
- 어떠한 정보들을 저장하기 위해 사용하는 개념
- 웹 서비스에서 사용할 정보의 내용, 특성 
    - 사이트의 게시물, 댓글, 회원 정보 등 > 처리하고 저장하기 위해 모델링이라는 과정을 거침
- 모델 클래스를 파이썬 클래스를 선언하여 정의 > 하나의 테이블로 만들어지고 데이터베이스는 여러 개의 테이블로 구성
    - 어떤 형태의 정보가 다뤄지고 저장될 지를 정의. Django 웹 앱 내에서 코드로 구현되고 웹 앱이 구동되면서 실제 DB와 연동됨


#### 예시 (맛집 사이트)
- 취급할 정보의 대략적인 정보: 맛집, 평가, 회원, 등
- 취급할 정보의 속성: 맛집(주소, 위치, 명칭, 전화번호, 사진 등), 평가(별점, 글쓴 시각, 글쓴 회원 등), 회원(이메일, 닉네임, 등)
- 속성의 자료형: 맛집(주소(string), 위치(위경도-부동소수점형), 명칭(string), 등)

#### 과정
1. `python manage.py makemigrations`: models.py에 정의된 클래스를 DB에서 받아들일 수 있도록 정의해줌
1. `python manage.py migrate`: DB로 migration됨
1. 추가
```bash
>>> post = Post.objects.create(title="this is title", content="this is content")
>>> post
<Post: Post object (1)>
>>> post.id
1
>>> post.title
'this is title'
>>> post.save()
>>> posts = Post.objects.all()
>>> posts
<QuerySet [<Post: Post object (1)>]>
```

### MTV(Model. Template. View)
- 기존 모델 패턴(MVC): M(Model) 데이터, V(View) 사용자 인터페이스, C(Controller) 데이터를 처리하는 로직
- Django 모델 패턴(MTV)
    - 모델(Model): 모델 클래스, 데이터 객체 정의와 그 데이터 (models.py)
    - 템플릿(Template): 사용자에게 보여지는 인터페이스 화면 (templates/*.html)
    - 뷰(View): 데이터를 가져오고 적절하게 가공하여 그 결과를 템플릿에 전달하는 역할 (views.py)
- http 요청과 응답의 흐름
    1. 클라이언트가 특정 주소로 요청
    1. Django에 웹앱 요청이 들어옴
    1. url conf 모듈을 이용하여 들어온 요청의 url을 확인
    1. 해당 url에 대한 처리를 담당하는 뷰를 결정 (urls.py)
    1. 뷰는 로직을 처리 
    1. (필요한 경우) 모델을 통해 데이터 처리
    1. 템플릿을 기반으로 최종 html 코드를 생성
    1. 생성된 html 코드를 클라이언트로 보냄
    1. 클라이언트가 받은 html 코드를 랜더링
